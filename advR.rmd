---
title: "Untitled"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(lobstr)
```

```{r}
x <- c(1,2,3)
y <- x
y[[3]] <- 4 # modifies 3rd object in vector

```

```{r}
# what happens when you run this?

x <- list(1:10)
x[[2]] <- x
```

## Vectors

For atomic vectors, type is a property of the entire vector: all elements must be the same type

Generally, you can deliberately coerce by using an as.*() function, like as.logical(), as.integer(), as.double(), or as.character().


```{r}
# What will these output?

c(1, FALSE) # 1 0

c("a",1) # "a" "1"

c(TRUE, 1L) # 1 1
```


```{r}
x <- 1:3
names(x) <- c("a", "b", "c")
```


## subsetting

using [ always returns the same object as is being modified

```{r}
x <- c(1,2,3,4,5)

x[3] # outputs the 3rd item in the vector

x[c(2,3)] # outputs the 2nd and 3rd item in the vector

x[c(1,1)] # duplicated indices output duplicated items

x[-c(1,2)] # excludes items at designated indices


# recycling rules 

x[c(TRUE, FALSE)]
# Equivalent to
x[c(TRUE, FALSE, TRUE, FALSE, TRUE)]


x[] # returns the original vector
```


```{r}
# now lets add a dimension!
(y <- setNames(x, letters[1:5]))

y[c("a","a","a")] # will output 3 replicas of a,1

```

```{r}
# lets go to matrices!!

# generally x[rows, columns]

a <- matrix(1:9, nrow = 3)
colnames(a) <- c("A", "B", "C")

a[1:2, ] # returns the first two rows 

a[c(TRUE, FALSE, TRUE), c("B", "A")] 
# returns first row, not second, returns third row. it then selects only B
# and A columns but they will be reordered in the order listed

a[0, -2] # returns no rows and every column name but the second, in this case A C

a[1,1] #returns first column entry of first row
```

```{r}
# Data frames and tibbles!

df <- data.frame(x = 1:3, y = 3:1, z = letters[1:3])

df[df$x == 2, ] # selects second column

df[2,] # does the same thing just much simpler and selects all columns

df[c(1, 3), ] # selects first and third rows and all columns


# the 3 ways to select columns

# like a list
df[c("x", "z")] 
# like a matrix
df[, c("x", "z")]
#by index as a matrix
df[,c(1,3)]

# importantly list subsetting does not simplify the output. This will tell you infor about a dataframe
str(df["x"])

# this will tell you info about a vector
str(df[, "x"])

# you can use drop = FALSE to avoid dropping dimensions
# the default of drop = T is often a bug in functions

str(df[, "x", drop = FALSE])

```

Exercises for subsetting

```{r}
data(mtcars)
```

```{r}
# fix the errors in these subsetting mistakes
-----
mtcars[mtcars$cyl = 4, ]
# fix
mtcars[mtcars$cyl == 4, ]
------

------
mtcars[-1:4, ]
# fix
mtcars[-(1:4),]
------
  
------
mtcars[mtcars$cyl <= 5]
# fix
mtcars[mtcars$cyl <= 5,]
------
  
------
mtcars[mtcars$cyl == (4 | 6), ]
# fix
mtcars[mtcars$cyl %in% c(4,6), ]


```

Using [[]] and $


difference between [[]] and []
  -If list x is a train carrying objects, then x[[5]] is the object in car 5; x[4:6] is a train of cars 4-6.

in other words you can either choose a smaller train or a specific item on a train!


```{r}
# another indexing option

x <- list(
  a = list(1, 2, 3),
  b = list(3, 4, 5)
)

purrr::pluck(x, "a", 1)

```

# exercises

Brainstorm as many ways as possible to extract the third value from the cyl variable in the mtcars dataset.

```{r}
# some options
mtcars$cyl[[3]]

mtcars[3,2]

mtcars[3, "cyl"]

mtcars[[c(2,3)]]
```


Given a linear model, extract the residual degrees of freedom. Then extract the R squared from the model summary (summary(mod))

```{r}
mod <- lm(mpg ~ wt, data = mtcars)
```

```{r}
names(mod)

# these both do the job
mod$df.residual

mod[["df.residual"]]

#rsq

names(summary(mod)) # just to check name

summary(mod)$r.squared

summary(mod)[["r.squared"]]
```

Subsetting and assignment

```{r}
x <- 1:5
x[c(1, 2)] <- c(101, 102) # changes the first and second entries to be 101 and 102

```

```{r}
#lists

x <- list(a = 1, b = 2)
x[["b"]] <- NULL # you can remove an element from a list by assignign null to it
str(x)


```

Applications

```{r}
# matching and merging

grades <- c(1, 2, 2, 3, 1)

info <- data.frame(
  grade = 3:1,
  desc = c("Excellent", "Good", "Poor"),
  fail = c(F, F, T)
)

id <- match(grades, info$grade)
info[id, ]
```

```{r}
# random samples and bootstraping

df <- data.frame(
  x = c(1, 2, 3, 1, 2),
  y = 5:1,
  z = letters[1:5]
  )

# shuffle rows

df[sample(nrow(df)),]

# Select 3 random rows
df[sample(nrow(df), 3), ]


# Select 6 bootstrap replicates
df[sample(nrow(df), 6, replace = TRUE), ]

```


```{r}
#ordering

x <- c("b", "c", "a")
order(x)

x[order(x)]

```

practice problems

How would you randomly permute the columns of a data frame? (This is an important technique in random forests.) Can you simultaneously permute the rows and columns in one step?

```{r}
df <- data.frame(
  x = c(1, 2, 3, 1, 2),
  y = 5:1,
  z = letters[1:5]
  )

df[,sample(ncol(df))] # permute columns

df[sample(nrow(df)), sample(ncol(df))] # permute rows and columns
```

How would you select a random sample of m rows from a data frame? What if the sample had to be contiguous (i.e., with an initial row, a final row, and every row in between)?

```{r}
df <- data.frame(
  x = c(1, 2, 3, 1, 2),
  y = 5:1,
  z = letters[1:5]
  )

df[sample(nrow(df),m), ] # selecting a random sample of m rows

start <- sample(nrow(df) - m + 1, 1) # selection some starting point relative to m rows
end <- start + m -1 # specifying the end index

df[start:end, drop = F]
```

If x is a matrix, x[] <- 0 will replace every element with 0, keeping the same number of rows and columns. In contrast, x <- 0 completely replaces the matrix with the value 0.


# Control Flow

```{r}
ifelse(test, yes, no)
```

```{r}
# this works but we'd like to write it more succinctly
x_option <- function(x) {
  if (x == "a") {
    "option 1"
  } else if (x == "b") {
    "option 2" 
  } else if (x == "c") {
    "option 3"
  } else {
    stop("Invalid `x` value")
  }
}

# switch should only really be used for character values of x
x_option_improved <- function(x) {
  switch(x,
    a = "option 1",
    b = "option 2",
    c = "option 3",
    stop("Invalid `x` value")
  )
}
# the last component of switch should always throw an error
```


If multiple inputs have the same output, you can leave the right hand side of = empty and the input will “fall through” to the next value.  

```{r}
legs <- function(x) {
  switch(x,
    cow = ,
    horse = ,
    dog = 4,
    human = ,
    chicken = 2,
    plant = 0,
    stop("Unknown input")
  )
}
legs("cow") # outputs 4

legs("dog") # outputs 4

legs("chicken") # outputs 2

```

Exercises

```{r}
#what do these output? 
ifelse(TRUE, 1, "no") # 1
ifelse(FALSE, 1, "no") # no
ifelse(NA, 1, "no") # NA 

```

cmd + shift + m is pipe %>%
option + - is arrow <-






