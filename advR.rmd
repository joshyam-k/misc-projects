---
title: "Untitled"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(lobstr)
```

```{r}
df <- data.frame(runif(3), runif(3))
names(df) <- c(1, 2)

# add a column called 3 that is the sum of columns `1` and `2`
df$`3` <- df$`1` + df$`2`
```

```{r}
x <- list(1:10)
x[[2]] <- x
# there is no second item in the list so a new item is created and set to be that list copied
```

```{r}
x <- c(1,2,3)
y <- x
y[[3]] <- 4 # modifies 3rd object in vector

```

```{r}
# what happens when you run this?

x <- list(1:10)
x[[2]] <- x
```

## Vectors

For atomic vectors, type is a property of the entire vector: all elements must be the same type

Generally, you can deliberately coerce by using an as.*() function, like as.logical(), as.integer(), as.double(), or as.character().


```{r}
# What will these output?

c(1, FALSE) # 1 0

c("a",1) # "a" "1"

c(TRUE, 1L) # 1 1
```


```{r}
x <- 1:3
names(x) <- c("a", "b", "c")
```

```{r}
x1 <- array(1:5, c(1, 1, 5)) # 1x1x5 3d object with 1 row 1 column and 5 different other layers
x2 <- array(1:5, c(1, 5, 1)) # 1x5x1 2d object with 1 row and 5 columns
x3 <- array(1:5, c(5, 1, 1)) # 5x1x1 2d object with 5 rows and 1 column
```

```{r}
# factors
x <- factor(c("a", "b", "b", "a"))
x # includes Levels: a b
```

```{r}
# What happens to a factor when you modify its levels?
f1 <- factor(letters)

as.integer(f1) # 1 2 3 ... 26

levels(f1) <- rev(levels(f1))
as.integer(f1) # 1 2 3 ... 26

# we can see that the underlying values are the same but the levels have changed making it seem like the data
# has changed. In other words reversing the levels doesn't change the data

# what happens here?
f2 <- rev(factor(letters)) # shows letters in reverse order but the factor levels are the usual a b c ...
as.integer(f2) # 26 25 24 ... 1

f3 <- factor(letters, levels = rev(letters)) # shows letters in normal order but levels in reverse order z y x .
as.integer(f3) # 26 25 24 ... 1

# For f2 and f3 either the order of the factor elements or its levels are being reversed. For f1 both
# transformations are occurring.
```

```{r}
# lists
l1 <- list(
  1:3, 
  "a", 
  c(TRUE, FALSE, TRUE), 
  c(2.3, 5.9)
)

typeof(l1) # check the type of the object
#> [1] "list"

str(l1)
#> List of 4
#>  $ : int [1:3] 1 2 3
#>  $ : chr "a"
#>  $ : logi [1:3] TRUE FALSE TRUE
#>  $ : num [1:2] 2.3 5.9

# elements of lists are references

# You can turn a list into an atomic vector with unlist(), but is messy and not super well documented

a <- list(1:3, 4:7)
unlist(a) # 1 2 3 4 5 6 7

# exercises
# List 3 ways that a list is different from an atomic vector (dimension, type of object, vectors point to one address in memory, and lists point to a separate address for each element)

# Why do you need to use unlist() to convert a list to an atomic vector? Why doesn’t as.vector() work?

a <- list("a", 1, FALSE)
unlist(a) # "a" "1" "FALSE"
as.vector(a) # returns the same thing as a

# this is because a list is already a vector!

```

```{r}
# data frames and tibbles
# a data frame is a named list of vectors, where the length of each vector must be the same

df1 <- data.frame(x = 1:3, y = letters[1:3])
typeof(df1) # "list"
attributes(df1) # $class "data.frame"

length(df1) # 2, length(data.frame) gives the number of columns
ncol(df1) # 2
nrow(df1) # 3

library(tibble)
df2 <- tibble(x = 1:3, y = letters[1:3])

###  creation -----------------------------------------------------------------

df <- data.frame(
  x = 1:3, 
  y = c("a", "b", "c"),
  stringsAsFactors = F # to prevent character vectors from being automatically converted into factors
)

str(df)

# while data frames automatically recycle columns that are an integer multiple of the longest column, tibbles
# will only recycle vectors of length one.

data.frame(x = 1:4, y = 1:3) # Error!
data.frame(x = 1:4, y = 1:2) # works!

tibble(x = 1:4, y = 1:2) # Error!
tibble(x = 1:4, y = 1) # works!

#There is one final difference: tibble() allows you to refer to variables created during construction:

tibble(
  x = 1:4,
  y = 2*x
  ) # works!

data.frame(
  x = 1:4,
  y = 2*x
) # doesn't do what we want

# In my opinion, data frames have two undesirable subsetting behaviours:

# if you subset columns with df[ , vars] you will get back a vector if vars selects one variable and a df
# otherwise which can lead to bugs

# Tibbles tweak these behaviors so that a [ always returns a tibble, and a $ doesn’t do partial matching and
# warns if it can’t find a variable

df1 <- data.frame(xyz = "a")
df2 <- tibble(xyz = "a")

str(df1$x)
#>  chr "a"
str(df2$x)
#> Warning: Unknown or uninitialised column: `x`.
#>  NULL

as_tibble(df1) # how to coerce a df into a tibble

```

```{r}
# Since a data frame is a list of vectors, it is possible for a data frame to have a column that is a list.

df <- data.frame(x = 1:3)
df$y <- list(1:2, 1:3, 1:4) # setting a new column y to be a list
# first row is 1, 2 second is 1, 2, 3 third is 1, 2, 3, 4

# alternatively
tibble(
  x = 1:3, 
  y = list(1:2, 1:3, 1:4)
) # displays the inputs in the y column as <int [2]>, <int [3]>, and <int [4]> and not their actual contents
```

```{r}
# exercises --------------------------------------------------------------------

# What happens if you attempt to set rownames that are not unique?

data.frame(
  a = 1:3, 
  y = 2:4,
  row.names = c("g","g","x")
) # error, duplicate names

# If df is a data frame, what can you say about t(df), and t(t(df))? Perform some experiments, making sure to
# try different column types.

df <- data.frame(
  a = 1:3,
  b = c("a", "b", "c")
)

t(df) # looks like this is transpose, in the case of characters and numerics it changed every element into a character additionally a matrix is returned

dfnew <- data.frame(
  a = c(T, F, T),
  b = c("ye", "ya", "yo")
)
t(dfnew) # again it changed them all to characters
str(t(dfnew))
t(t(dfnew)) # changes it back but elements remain as character, # still a matrix!

```

```{r}
# NULL

typeof(NULL)
#> [1] "NULL"

length(NULL)
#> [1] 0

is.null(NULL) # TRUE

c() # NULL
```

## subsetting


```{r}
x <- c(1,2,3,4,5)

x[3] # outputs the 3rd item in the vector

x[c(2,3)] # outputs the 2nd and 3rd item in the vector

x[c(1,1)] # duplicated indices output duplicated items

x[-c(1,2)] # excludes items at designated indices


# recycling rules 

x[c(TRUE, FALSE)]
# Equivalent to
x[c(TRUE, FALSE, TRUE, FALSE, TRUE)]


x[] # returns the original vector
```


```{r}
# now lets add a dimension!
(y <- setNames(x, letters[1:5]))

y[c("a","a","a")] # will output 3 replicas of a,1

```

```{r}
# lets go to matrices!!

# generally x[rows, columns]

a <- matrix(1:9, nrow = 3)
colnames(a) <- c("A", "B", "C")

a[1:2, ] # returns the first two rows 

a[c(TRUE, FALSE, TRUE), c("B", "A")] 
# returns first row, not second, returns third row. it then selects only B
# and A columns but they will be reordered in the order listed

a[0, -2] # returns no rows and every column name but the second, in this case A C

a[1,1] #returns first column entry of first row
```

```{r}
# lists

# using [] will return a list and using [[]] or $ will return an item from the list

a <- list(list("a","b"), 1:3)
a[[1]][[1]] # so we are selecting the list at first and second we are selecting the first element in the list
```

```{r}
# Data frames and tibbles!

df <- data.frame(x = 1:3, y = 3:1, z = letters[1:3])

df[df$x == 2, ] # selects second row

df[2,] # does the same thing just much simpler and selects all columns

df[c(1, 3), ] # selects first and third rows and all columns


# the 3 ways to select columns

# like a list
df[c("x", "z")] 
# like a matrix
df[, c("x", "z")]
#by index as a matrix
df[,c(1,3)]

# importantly list subsetting does not simplify the output. This will tell you info about a dataframe
str(df["x"])

# this will tell you info about a vector
str(df[, "x"])

# you can use drop = FALSE to avoid dropping dimensions
# the default of drop = T is often a bug in functions

str(df[, "x", drop = FALSE])
 
# subsetting a tibble with [] always returns a tibble which is a really nice feature, avoid dimensionality drops
```

```{r}
# matrices

# Because both matrices and arrays are just vectors with special attributes, you can subset them with a single
# vector, as if they were a 1D vector. Note that arrays in R are stored in column-major order:
vals <- outer(1:5, 1:5, FUN = "paste", sep = ",")
vals

vals[c(4,15)] # if you were to lay out the matrix in column major order so the first column followed by 
# the second columna and then count the indices youd get that output using this code
# in this case it is "4,1" "5,3"

```

```{r}
# preserving dimensionality

# Data frames with a single column will return just the content of that column:
df <- data.frame(a = 1:2, b = 1:2)
str(df) # `data.frame`
str(df[, "a"]) # now when we subset a single column we lose dimension
#>  int [1:2] 1 2

# we can avoid this by using a tibble or by doing
str(df[, "a", drop = FALSE]) # `data.frame`

# if not using a tibble, When writing functions, get in the habit of always using drop = FALSE when subsetting a
# 2D object. 
```

```{r}

```

Exercises for subsetting

```{r}
data(mtcars)
```

```{r}
# fix the errors in these subsetting mistakes
-----
mtcars[mtcars$cyl = 4, ]
# fix
mtcars[mtcars$cyl == 4, ]
------

------
mtcars[-1:4, ]
# fix
mtcars[-(1:4),]
------
  
------
mtcars[mtcars$cyl <= 5]
# fix
mtcars[mtcars$cyl <= 5,]
------
  
------
mtcars[mtcars$cyl == (4 | 6), ]
# fix
mtcars[mtcars$cyl %in% c(4,6), ]

# why does the following return all NA

x <- 1:5
x[NA] # NA NA NA NA NA
#  In contrast to NA_real, NA has logical type and logical vectors are recycled to the same length as the
# vector being subset, i.e. x[NA] is recycled to x[NA, NA, NA, NA, NA]

# what does upper.tri do?
x <- outer(1:5, 1:5, FUN = "*") # this creates a matrix
x[upper.tri(x)] # takes the upper triangle of the matrix not including the line of symmetry

# Why does mtcars[1:20] return an error? How does it differ from the similar mtcars[1:20, ]?

mtcars[1:20] # this would return the first 20 columns but there are only 11
# its only when we use mtcars[1:20, ] that the 1:20 will refer to rows and not columns

# write a function to pull diagonal values in a matrix

diags <- function(matrix){
  vals <- c()
  for (i in 1:nrow(matrix)){
    vals[i] <- matrix[i,i]
  }
  vals
}
diags(x) # lol this works!

# alternatively

diag2 <- function(x) {
  n <- nrow(x)
  idx <- cbind(seq_len(n), seq_len(n)) # creates a matrix where the first row is 1 1 second is 2 2 and so on

  x[idx] # we can subset by using our matrix of coordinates essentially
}

diag2(x)

# What does df[is.na(df)] <- 0 do?
# it replaces all NA's in a dataframe with 0
```

Using [[]] and $


difference between [[]] and []
  -If list x is a train carrying objects, then x[[5]] is the object in car 5; x[4:6] is a train of cars 4-6.

in other words you can either choose a smaller train or a specific item on a train!

```{r}
# it is recommended to use [[]] when selecting a single element from an atomic vector even though you do not 
# have to. This reinforces the notion that you are getting and expecting an individual element

# One common mistake with $ is to use it when you have the name of a column stored in a variable:
var <- "cyl"
# Doesn't work - mtcars$var translated to mtcars[["var"]]
mtcars$var
#> NULL

# Instead use [[
mtcars[[var]] # [1] 6 6 4 6 8 6 8 4 4 6 6 8 8 8 8 8 8 4 4 4 4 8 8 8 8 4 4 4 8 6 8 4

# The one important difference between $ and [[ is that $ does (left-to-right) partial matching:

x <- list(abs = 1)

x$a # 1
x[["a"]] # NULL

# a good practice is to do
options(warnPartialMatchDollar = TRUE)
x$a # Warning message: In x$a : partial match of 'a' to 'abs'

# in the land of dataframes you can avoid this by using tibbles which never partial match
```



```{r}
# another indexing option

x <- list(
  a = list(1, 2, 3),
  b = list(3, 4, 5)
)

purrr::pluck(x, "a", 1)

```

# exercises

Brainstorm as many ways as possible to extract the third value from the cyl variable in the mtcars dataset.

```{r}
# some options
mtcars$cyl[[3]]

mtcars[3,2]

mtcars[3, "cyl"]

mtcars[[c(2,3)]]
```


Given a linear model, extract the residual degrees of freedom. Then extract the R squared from the model summary (summary(mod))

```{r}
mod <- lm(mpg ~ wt, data = mtcars)
```

```{r}
names(mod)

# these both do the job
mod$df.residual

mod[["df.residual"]]

#rsq

names(summary(mod)) # just to check name

summary(mod)$r.squared

summary(mod)[["r.squared"]]
```

Subsetting and assignment

```{r}
x <- 1:5
x[c(1, 2)] <- c(101, 102) # changes the first and second entries to be 101 and 102

```

```{r}
#lists

x <- list(a = 1, b = 2)
x[["b"]] <- NULL # you can remove an element from a list by assignign null to it
str(x)


```

Applications

```{r}
# matching and merging

grades <- c(1, 2, 2, 3, 1)

info <- data.frame(
  grade = 3:1,
  desc = c("Excellent", "Good", "Poor"),
  fail = c(F, F, T)
)

id <- match(grades, info$grade)
info[id, ]
```

```{r}
# random samples and bootstraping

df <- data.frame(
  x = c(1, 2, 3, 1, 2),
  y = 5:1,
  z = letters[1:5]
  )

# shuffle rows

df[sample(nrow(df)),]

# Select 3 random rows
df[sample(nrow(df), 3), ]


# Select 6 bootstrap replicates
df[sample(nrow(df), 6, replace = TRUE), ]

```


```{r}
#ordering

x <- c("b", "c", "a")
order(x)

x[order(x)]

```

practice problems

How would you randomly permute the columns of a data frame? (This is an important technique in random forests.) Can you simultaneously permute the rows and columns in one step?

```{r}
df <- data.frame(
  x = c(1, 2, 3, 1, 2),
  y = 5:1,
  z = letters[1:5]
  )

df[,sample(ncol(df))] # permute columns

df[sample(nrow(df)), sample(ncol(df))] # permute rows and columns
```

How would you select a random sample of m rows from a data frame? What if the sample had to be contiguous (i.e., with an initial row, a final row, and every row in between)?

```{r}
df <- data.frame(
  x = c(1, 2, 3, 1, 2),
  y = 5:1,
  z = letters[1:5]
  )

df[sample(nrow(df),m), ] # selecting a random sample of m rows

start <- sample(nrow(df) - m + 1, 1) # selection some starting point relative to m rows
end <- start + m -1 # specifying the end index

df[start:end, drop = F]
```

If x is a matrix, x[] <- 0 will replace every element with 0, keeping the same number of rows and columns. In contrast, x <- 0 completely replaces the matrix with the value 0.

```{r}
# How could you put the columns in a data frame in alphabetical order?
df <- data.frame(
  c = c(1, 2, 3, 1, 2),
  b = 5:1,
  a = letters[1:5]
  )

df[order(names(df))] # use order and names
```


# Control Flow

```{r}
ifelse(test, yes, no)
```

```{r}
# this works but we'd like to write it more succinctly
x_option <- function(x) {
  if (x == "a") {
    "option 1"
  } else if (x == "b") {
    "option 2" 
  } else if (x == "c") {
    "option 3"
  } else {
    stop("Invalid `x` value")
  }
}

# switch should only really be used for character values of x
x_option_improved <- function(x) {
  switch(x,
    a = "option 1",
    b = "option 2",
    c = "option 3",
    stop("Invalid `x` value")
  )
}
# the last component of switch should always throw an error
```


If multiple inputs have the same output, you can leave the right hand side of = empty and the input will “fall through” to the next value.  

```{r}
legs <- function(x) {
  switch(x,
    cow = ,
    horse = ,
    dog = 4,
    human = ,
    chicken = 2,
    plant = 0,
    stop("Unknown input")
  )
}
legs("cow") # outputs 4

legs("dog") # outputs 4

legs("chicken") # outputs 2

```

Exercises

```{r}
#what do these output? 
ifelse(TRUE, 1, "no") # 1
ifelse(FALSE, 1, "no") # no
ifelse(NA, 1, "no") # NA 

```

cmd + shift + m is pipe %>%
option + - is arrow <-


# Functions

A function has three parts:

  - The formals(), the list of arguments that control how you call the function.

  - The body(), the code inside the function.

  - The environment(), the data structure that determines how the function finds the values associated with the     names.

```{r}
f02 <- function(x, y) {
  # A comment
  x + y
}

formals(f02)


body(f02)


environment(f02)

```

a pretty useful way to look at the makeup of a function

```{r}
attr(f02, "srcref")

#> function(x, y) {
#>   # A comment
#>   x + y
#> }
```


A good rule of thumb is that an anonymous function should fit on one line and shouldn’t need to use {}.

```{r}
sapply(mtcars, function(x) length(unique(x)))
```


```{r}
match.fun(mean)
```

Lexical scoping

-four primary rules it follows

```{r}
# Name Masking
#   -names defined inside a function mask names defined outside a function

x <- 10
y <- 20
g02 <- function() {
  x <- 1
  y <- 2
  c(x, y)
}
g02() # outputs 1 2 not 10 20

# If a name isn’t defined inside a function, R looks one level up.

x <- 2
g03 <- function() {
  y <- 1
  c(x, y)
}
g03() # outputs 2 1 and importantly

y # ouputs 20 which was the old value for y
```

```{r}
# Functions vs variables

# the same scoping rules apply to functions as well as objects

g09 <- function(x) x + 100
g10 <- function() {
  g09 <- 10
  g09(g09)
}
g10() # this outputs 110 because we have both an object and a function defined as g09

```

```{r}
# A fresh start

#every time a function is called a new environment is created to host its execution. This means that a function #has no way to tell what happened the last time it was run; each invocation is completely independent.
```

```{r}
# dynamic lookup

# R looks for values when the function is run, not when the function is created

g12 <- function() x + 1
x <- 15
g12() # outputs 16


x <- 20
g12() # outputs 21, because we assigned 20 to x before running the function again



```


```{r}
c <- 10
c(c = c)
```

What does this do?

```{r}
f <- function(x) {
  f <- function(x) {
    f <- function() {
      x ^ 2
    }
    f() + 1
  }
  f(x) * 2
}
f(10) # 202
```

Lazy evaluation

```{r}
# promises

# three components

# an expression which gives rise to delayed computation
# an environment where the expression should be evaluated
#   This also means that when you do assignment inside a call to a function, the variable is bound outside of the
#   function, not inside of it.
# A value, which is computed and cached the first time a promise is accessed when the expression is evaluated in
# the specified environment.
```

```{r}
# default arguments

h04 <- function(x = 1, y = x * 2, z = a + b) {
  a <- 10
  b <- 100
  
  c(x, y, z)
}

h04() # outputs 1 2 110 this shows off default values that we set ourselves


# missing arguments


```

```{r}
args(sample) # a cool way to check arguments of a function, notice no ()
```

```{r}
sample1 <- function(x, size = NULL, replace = FALSE, prob = NULL) {
  if (is.null(size)) {
    size <- length(x)
  }
  
  x[sample.int(length(x), size, replace = replace, prob = prob)]
}

sample1(1:20)
sample(1:20)
```

&& does not perform elementwise comparisons, instead it uses the first element of each value only

```{r}
attr(sample, "srcref")
args(sample)
```


```{r}
f2 <- function(x = z) {
  z <- 100
  x
}
f2()
```

```{r}
y <- 10
f1 <- function(x = {y <- 1; 2}, y = 0) {
  c(x, y)
}
f1()

```

```{r}
# dot-dot-dot ...

i04 <- function(...) {
  list(...)
}

i04(a = 1, b = 2, j = "jack") # just an example

# the primary uses of ...

#If your function takes a function as an argument, you want some way to pass additional arguments to that #function.

# some downsides, a misspelled argument will not cause an error

sum(1,2,3,NA, na_rm = T) # returns NA since we typed na_rm not na.rm

```


```{r}
args(mean)

sum(1, 2, 3, na.omit = TRUE) # returns 7 because we wrote na.omit instead of na.rm and so the T is read as 1

# lets look at the arguments

str(sum) # we can see that the first arguments are ... and the other is the status of na.rm, so we can do
sum(1,2,3,4)

str(mean) # here we can see that x is the first argument and the rest is ... so we cant do 
mean(1,2,3)
# instead we do
mean(c(1,2,3))

str(plot)
```

```{r}
# exiting a function

# Most functions exit in one of two ways: they either return a value, indicating success, or they throw an
# error, indicating failure

# implicit vs explicit

## implicitly, where the last evaluated expression is the return value:
## Explicitly, by calling return()

# invisible values

j03 <- function() 1
j03() # usually it works like this where just calling the function prints an output

# but we can also do this to prevent the output from being printed
j04 <- function() invisible(1)
j04() # this outputs nothing

# the most common usage of invisible functions is the <-, for ex a <- 1 doesnt output anything

# to see the output we can wrap in parenthesis

(j04()) # this outputs 1 which is normally invisible
```

### Environments

```{r}
library(rlang)

# how to create an environment
e1 <- env(
  a = FALSE,
  b = "a",
  c = 2.3,
  d = 1:3,
)

# use new.env to create a new environment

env_print(e1) # this helps you look at environment
env_names(e1)
```


```{r}
# important environments

current_env()

global_env()

identical(current_env(), global_env()) # outputs TRUE
```

```{r}
# parents

# every environment has a parent, another environment
# if a name is not found in an environment R will look to the parent and so on

e2a <- env(d = 4, e = 5)
e2b <- env(e2a, a = 1, b = 2, c = 3)

env_print(e2a)

# you can find the parent of an environment with
env_parent(e2b)
env_parent(e2a) # R_GlobalEnv
env_parents(e2b) # shows entire ancestry, this stops at the global environment

# the empty environment has no parent

env_parent(empty_env()) # Error the environment has no parent

env_parents(e2b, last = empty_env()) # we can override stopping at the global environment as follows
# this shows every package too

```


```{r}
# super assignment <<-

# Regular assignment, <-, always creates a variable in the current environment. Super assignment, <<-, never
# creates a variable in the current environment, but instead modifies an existing variable found in a parent
# environment.

x <- 0
f <- function() {
  x <- 1
}
f()
x

# in this case when we run the function and then check on x again we see that it still has the value 0
y <- 0
g <- function() {
  y <<- 1
}
g()
y
# now when we run the function the value y has been replaced to be 1, this outputs 1 not 0

# if <<- doesn't find an existing variable it will create one in the global environment

```


```{r}
# getting and setting

e3 <- env(x = 1, y = 2)
e3$x # outputs 1

e3$z <- 3
env_print(e3) # this shows a z value now
e3$z # outputs 3

e3[["z"]] # outputs 3

# but you cant use numeric indices, you also can't use []

# two other ways to add bindings to an environment

env_poke(e3, "a", 100)
e3$a # outputs 100

env_bind(e3, a = 10, b = 20)
env_names(e3) # outputs x y z a b

# to remove bindings

env_unbind(e3, "a")
env_print(e3) # now a no longer exists in this environment


```

```{r}
# advanced bindings

env_bind_active(current_env(), z1 = function(val) runif(1))
z1 
z1 # these output a new value each time theyre accessed

```


```{r}
# exercises

# 1
e1 <- env(
  loop = e1
)

# Create a version of env_poke() that will only bind new names, never re-bind old names. Some programming
# languages only do this, and are known as single assignment languages.

env_poke1 <- function(env, name, value){
  if (env_has(env, name)) {
    abort(paste0("\"", name, "\" is already assigned to a value."))
  }
  env_poke(env, name, value)
  invisible(env) 
}

# lets test it
env_poke1(e3, "w", 100)
e3$w # 100

env_poke1(e3, "w", 200) # Error: "w" is already assigned to a value
```

```{r}
# recursion over environments

# This section shows you how, applying your new knowledge of environments to write a function that given a name,
# finds the environment where() that name is defined, using R’s regular scoping rules.

where <- function(name, env = caller_env()) { 
  # default is caller_env() for the environment to start in
  # The caller environment is the execution environment of the function that called the current function.
  if (identical(env, empty_env())) {
    # checking to see if the env is the empty environment
    # Base case
    stop("Can't find ", name, call. = FALSE)
  } else if (env_has(env, name)) {
    # Success case
    env
  } else {
    # Recursive case
    # looks at the parent of env to continue
    where(name, env_parent(env))
  }
}

# this function is really nice because it checks each successive parent environment until it finds which environment the value lives in

where("yyy")
# Error: Can't find yyy

x <- 5
where("x")
# <environment: R_GlobalEnv>

where("mean")
# <environment: base>



```

```{r}
# exercises

# Modify where() to return all environments that contain a binding for name. Carefully think through what type of
# object the function will need to return.

where2 <- function(name, env = caller_env(), results = list()) {
  if (identical(env, empty_env())) {
    # Base case
    results
  } else {
    # Recursive case
    if (env_has(env, name)) {
      results <- c(results, env)
    }
    where2(name, env_parent(env), results)
  }
}

e1a <- env(empty_env(), a = 1, b = 2)
e1b <- env(e1a, b = 10, c = 11)
e1c <- env(e1b, a = 12, d = 13)

where2("a", e1c)

```

```{r}
# special environments
# Most environments are not created by you (e.g. with env()) but are instead created by R
search()
search_envs()

# namespaces
# every package works the same way regardless of what packages are attached by the user.

#ex
sd # notice it lives in the namespace:stats environment

# Each time a function is called, a new environment is created to host execution

g <- function(x) {
  if (!env_has(current_env(), "a")) {
    message("Defining a")
    a <- 1
  } else {
    a <- a + 1
  }
  a
}

g(10) # these output the same thing becayse a new environment is created to host execution each time it is run
g(10)

```

### Conditions

```{r}
library(rlang)

# signaling conditions

# errors, warnings, and messages

stop("This is what an error looks like")
#> Error in eval(expr, envir, enclos): This is what an error looks like

warning("This is what a warning looks like")
#> Warning: This is what a warning looks like

message("This is what a message looks like")
#> This is what a message looks like
```

Errors:

```{r}
h <- function() stop("this is an error!")
h() # Error in h() : this is an error!

# if we don't want "in h()" use
j <- function() stop("this is an error!", call. = F)
j() # Error: this is an error!

# we can just use abort() to fix this

m <- function() abort("no no no")
m() # you can use glue to create more complex error messages

```

Warnings:

```{r}
fw <- function() {
  cat("1\n")
  warning("W1")
  cat("2\n")
  warning("W2")
  cat("3\n")
  warn("W3") # warn() can also be used (its in rlang)
}

fw()
```

Messages:

```{r}
# message()s are displayed immediately and do not have a call. argument

fm <- function() {
  cat("1\n")
  message("M1")
  cat("2\n")
  message("M2")
  cat("3\n")
  message("M3")
}

fm() # check output to see how message works
```

```{r}
# exercises

file_remove <- function(file){
  if (!file.exists(file)){
    stop("Can't delete the file \"", file,
          "\"because it doesn't exist",
         call. = F)
  }
  file.remove(file)
}

saveRDS(mtcars, "mtcars.rds")
file_remove("mtcars.rds")
#> [1] TRUE
file_remove("mtcars.rds")
# Error: Can't delete the file "mtcars.rds"because it doesn't exist


# what does appendLF do in the message function

k <- function(){
  message("what", appendLF = T)
  message("is", appendLF = T)
  message("that", appendLF = T)
}

k() # it creates a new line
```


Ignoring conditions

  - Ignore errors with try().
  - Ignore warnings with suppressWarnings().
  - Ignore messages with suppressMessages().

```{r}
#try()

f1 <- function(x) {
  log(x)
  10
}
f1("x")
# Error in log(x): non-numeric argument to mathematical function

f2<- function(x) {
  try(log(x))
  10
}
f2("x") # 10

# a useful trick is to use assignment inside of the call

# as you can see here we only assign default to be something else if the code runs without an error!
default <- NULL
try(default <- read.csv("possibly-bad-input.csv"), silent = TRUE)

```

```{r}
# condition objects

cnd <- catch_cnd(stop("An error"))
str(cnd)

#> List of 2
#>  $ message: chr "An error"
#>  $ call   : language force(expr)
#>  - attr(*, "class")= chr [1:3] "simpleError" "error" "condition"
```

```{r}
# tryCatch()

tryCatch(
  error = function(cnd) {
    # code to run when error is thrown
  },
  code_to_run_while_handlers_are_active
)

# tryCatch() defines exiting handlers; after the condition is handled, control returns to the context where tryCatch() was called. This makes tryCatch() most suitable for working with errors and interrupts, as these have to exit anyway

#exiting handlers
# tryCatch() registers exiting handlers, and is typically used to handle error conditions. It allows you to
# override the default error behaviour.

f3 <- function(x) {
  tryCatch(
    error = function(cnd) NA,
    log(x)
  )
}

f3("x") #NA, allows you to overide an error message as you want

tryCatch(
  error = function(cnd) {
    paste0("--", conditionMessage(cnd), "--")
  },
  stop("This is an error")
) # "--This is an error--"

```

From what I can understand, inside of tryCatch() you use brackets to specify what to do in the case of messages, warnings, and errors
```{r}
# calling handlers

tryCatch(
  message = function(cnd) cat("Caught a message!\n"), 
  {
    message("Someone there?")
    message("Why, yes!")
  }
) # Caught a message! 


```

```{r}
# i find this example of tryCatch to be especially helpful

# we want our function to read a vector of urls, but we dont want it to only output an error when it comes
# across an invalid url, instead we want it to keep working and then print information about that error
# at the end

urls <- c(
    "http://stat.ethz.ch/R-manual/R-devel/library/base/html/connections.html",
    "http://en.wikipedia.org/wiki/Xz",
    "xxxxx"
)

readUrl <- function(url) {
    out <- tryCatch(
        {
            # 'tryCatch()' will return the last evaluated expression 
            # in case the "try" part was completed successfully

            message("This is the 'try' part")

            readLines(con = url, warn=FALSE) 
            # The return value of `readLines()` is the actual value 
            # that will be returned in case there is no condition 
            # (e.g. warning or error). 
            # You don't need to state the return value via `return()` as code 
            # in the "try" part is not wrapped inside a function (unlike that
            # for the condition handlers for warnings and error below)
        },
        error = function(cond) { 
            # this is specifying what to do in the case of an error
            message(paste("URL does not seem to exist:", url))
            message("Here's the original error message:")
            message(cond)
            # Choose a return value in case of error
            return(NA)
        },
            # this is specifying what to do in case of a warning
        warning = function(cond) {
            message(paste("URL caused a warning:", url))
            message("Here's the original warning message:")
            message(cond)
            # Choose a return value in case of warning
            return(NULL)
        },
        finally={
        # NOTE:
        # Here goes everything that should be executed at the end,
        # regardless of success or error.
        # If you want more than one expression to be executed, then you 
        # need to wrap them in curly brackets ({...}); otherwise you could
        # just have written 'finally=<expression>' 
            message(paste("Processed URL:", url))
            message("Some other message at the end")
        }
    )    
    return(out)
}


# lets test it
y <- lapply(urls, readUrl)

# This is the 'try' part
# Processed URL: http://stat.ethz.ch/R-manual/R-devel/library/base/html/connections.html
# Some other message at the end
# This is the 'try' part
# Processed URL: http://en.wikipedia.org/wiki/Xz
# Some other message at the end
# This is the 'try' part
# URL caused a warning: xxxxx
# Here's the original warning message:
# cannot open file 'xxxxx': No such file or directoryProcessed URL: xxxxx
# Some other message at the end


# so cool!!!
```


Exercises

```{r}
# predict outputs of this function
show_condition <- function(code) {
  tryCatch(
    error = function(cnd) "error",
    warning = function(cnd) "warning",
    message = function(cnd) "message",
    {
      code
    }
  )
}

show_condition(stop("!"))
# outputs "error" since we entered an error lol

show_condition(10)
# outputs 10 since no condition is signaled

show_condition(warning("?!"))
# outputs "warning" since we triggered a warning

show_condition({
  10
  message("?")
  warning("?!")
})
# just outputs "message" because it termiantes as soon as it's called
```

```{r}
# custom conditions

abort(
  "error_not_found", # name of the type of error
  message = "Path `blah.csv` not found", # user facing text
  path = "blah.csv" # custom metadata
)
# Error: Path `blah.csv` not found

# lets look at the log functions errors to get a  sense of where this is useful

log(letters)
#> Error in log(letters): non-numeric argument to mathematical function
log(1:10, base = letters)
#> Error in log(1:10, base = letters): non-numeric argument to mathematical function

# lets write a new function

my_log <- function(x, base = exp(1)){
  if (!is.numeric(x)){
    abort(
      paste0("`x` must be a numeric vector, not ", type_of(x), ".")
    )
  }
  if (!is.numeric(base)){
    abort(
      paste0("`base` must be a numeric vector not ", type_of(base), ".")
    )
  }
  base::log(x, base = base)
}

my_log(letters)
# Error: `x` must be a numeric vector, not character.
my_log(1:10, base = letters)
# Error: `base` must be a numeric vector, not character.
```

```{r}
# applications


```

