---
title: "Untitled"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(lobstr)
```

```{r}
x <- c(1,2,3)
y <- x
y[[3]] <- 4 # modifies 3rd object in vector

```

```{r}
# what happens when you run this?

x <- list(1:10)
x[[2]] <- x
```

## Vectors

For atomic vectors, type is a property of the entire vector: all elements must be the same type

Generally, you can deliberately coerce by using an as.*() function, like as.logical(), as.integer(), as.double(), or as.character().


```{r}
# What will these output?

c(1, FALSE) # 1 0

c("a",1) # "a" "1"

c(TRUE, 1L) # 1 1
```


```{r}
x <- 1:3
names(x) <- c("a", "b", "c")
```


## subsetting

using [ always returns the same object as is being modified

```{r}
x <- c(1,2,3,4,5)

x[3] # outputs the 3rd item in the vector

x[c(2,3)] # outputs the 2nd and 3rd item in the vector

x[c(1,1)] # duplicated indices output duplicated items

x[-c(1,2)] # excludes items at designated indices


# recycling rules 

x[c(TRUE, FALSE)]
# Equivalent to
x[c(TRUE, FALSE, TRUE, FALSE, TRUE)]


x[] # returns the original vector
```


```{r}
# now lets add a dimension!
(y <- setNames(x, letters[1:5]))

y[c("a","a","a")] # will output 3 replicas of a,1

```

```{r}
# lets go to matrices!!

# generally x[rows, columns]

a <- matrix(1:9, nrow = 3)
colnames(a) <- c("A", "B", "C")

a[1:2, ] # returns the first two rows 

a[c(TRUE, FALSE, TRUE), c("B", "A")] 
# returns first row, not second, returns third row. it then selects only B
# and A columns but they will be reordered in the order listed

a[0, -2] # returns no rows and every column name but the second, in this case A C

a[1,1] #returns first column entry of first row
```

```{r}
# Data frames and tibbles!

df <- data.frame(x = 1:3, y = 3:1, z = letters[1:3])

df[df$x == 2, ] # selects second row

df[2,] # does the same thing just much simpler and selects all columns

df[c(1, 3), ] # selects first and third rows and all columns


# the 3 ways to select columns

# like a list
df[c("x", "z")] 
# like a matrix
df[, c("x", "z")]
#by index as a matrix
df[,c(1,3)]

# importantly list subsetting does not simplify the output. This will tell you info about a dataframe
str(df["x"])

# this will tell you info about a vector
str(df[, "x"])

# you can use drop = FALSE to avoid dropping dimensions
# the default of drop = T is often a bug in functions

str(df[, "x", drop = FALSE])

```

Exercises for subsetting

```{r}
data(mtcars)
```

```{r}
# fix the errors in these subsetting mistakes
-----
mtcars[mtcars$cyl = 4, ]
# fix
mtcars[mtcars$cyl == 4, ]
------

------
mtcars[-1:4, ]
# fix
mtcars[-(1:4),]
------
  
------
mtcars[mtcars$cyl <= 5]
# fix
mtcars[mtcars$cyl <= 5,]
------
  
------
mtcars[mtcars$cyl == (4 | 6), ]
# fix
mtcars[mtcars$cyl %in% c(4,6), ]


```

Using [[]] and $


difference between [[]] and []
  -If list x is a train carrying objects, then x[[5]] is the object in car 5; x[4:6] is a train of cars 4-6.

in other words you can either choose a smaller train or a specific item on a train!


```{r}
# another indexing option

x <- list(
  a = list(1, 2, 3),
  b = list(3, 4, 5)
)

purrr::pluck(x, "a", 1)

```

# exercises

Brainstorm as many ways as possible to extract the third value from the cyl variable in the mtcars dataset.

```{r}
# some options
mtcars$cyl[[3]]

mtcars[3,2]

mtcars[3, "cyl"]

mtcars[[c(2,3)]]
```


Given a linear model, extract the residual degrees of freedom. Then extract the R squared from the model summary (summary(mod))

```{r}
mod <- lm(mpg ~ wt, data = mtcars)
```

```{r}
names(mod)

# these both do the job
mod$df.residual

mod[["df.residual"]]

#rsq

names(summary(mod)) # just to check name

summary(mod)$r.squared

summary(mod)[["r.squared"]]
```

Subsetting and assignment

```{r}
x <- 1:5
x[c(1, 2)] <- c(101, 102) # changes the first and second entries to be 101 and 102

```

```{r}
#lists

x <- list(a = 1, b = 2)
x[["b"]] <- NULL # you can remove an element from a list by assignign null to it
str(x)


```

Applications

```{r}
# matching and merging

grades <- c(1, 2, 2, 3, 1)

info <- data.frame(
  grade = 3:1,
  desc = c("Excellent", "Good", "Poor"),
  fail = c(F, F, T)
)

id <- match(grades, info$grade)
info[id, ]
```

```{r}
# random samples and bootstraping

df <- data.frame(
  x = c(1, 2, 3, 1, 2),
  y = 5:1,
  z = letters[1:5]
  )

# shuffle rows

df[sample(nrow(df)),]

# Select 3 random rows
df[sample(nrow(df), 3), ]


# Select 6 bootstrap replicates
df[sample(nrow(df), 6, replace = TRUE), ]

```


```{r}
#ordering

x <- c("b", "c", "a")
order(x)

x[order(x)]

```

practice problems

How would you randomly permute the columns of a data frame? (This is an important technique in random forests.) Can you simultaneously permute the rows and columns in one step?

```{r}
df <- data.frame(
  x = c(1, 2, 3, 1, 2),
  y = 5:1,
  z = letters[1:5]
  )

df[,sample(ncol(df))] # permute columns

df[sample(nrow(df)), sample(ncol(df))] # permute rows and columns
```

How would you select a random sample of m rows from a data frame? What if the sample had to be contiguous (i.e., with an initial row, a final row, and every row in between)?

```{r}
df <- data.frame(
  x = c(1, 2, 3, 1, 2),
  y = 5:1,
  z = letters[1:5]
  )

df[sample(nrow(df),m), ] # selecting a random sample of m rows

start <- sample(nrow(df) - m + 1, 1) # selection some starting point relative to m rows
end <- start + m -1 # specifying the end index

df[start:end, drop = F]
```

If x is a matrix, x[] <- 0 will replace every element with 0, keeping the same number of rows and columns. In contrast, x <- 0 completely replaces the matrix with the value 0.


# Control Flow

```{r}
ifelse(test, yes, no)
```

```{r}
# this works but we'd like to write it more succinctly
x_option <- function(x) {
  if (x == "a") {
    "option 1"
  } else if (x == "b") {
    "option 2" 
  } else if (x == "c") {
    "option 3"
  } else {
    stop("Invalid `x` value")
  }
}

# switch should only really be used for character values of x
x_option_improved <- function(x) {
  switch(x,
    a = "option 1",
    b = "option 2",
    c = "option 3",
    stop("Invalid `x` value")
  )
}
# the last component of switch should always throw an error
```


If multiple inputs have the same output, you can leave the right hand side of = empty and the input will “fall through” to the next value.  

```{r}
legs <- function(x) {
  switch(x,
    cow = ,
    horse = ,
    dog = 4,
    human = ,
    chicken = 2,
    plant = 0,
    stop("Unknown input")
  )
}
legs("cow") # outputs 4

legs("dog") # outputs 4

legs("chicken") # outputs 2

```

Exercises

```{r}
#what do these output? 
ifelse(TRUE, 1, "no") # 1
ifelse(FALSE, 1, "no") # no
ifelse(NA, 1, "no") # NA 

```

cmd + shift + m is pipe %>%
option + - is arrow <-


# Functions

A function has three parts:

  - The formals(), the list of arguments that control how you call the function.

  - The body(), the code inside the function.

  - The environment(), the data structure that determines how the function finds the values associated with the     names.

```{r}
f02 <- function(x, y) {
  # A comment
  x + y
}

formals(f02)


body(f02)


environment(f02)

```

a pretty useful way to look at the makeup of a function

```{r}
attr(f02, "srcref")

#> function(x, y) {
#>   # A comment
#>   x + y
#> }
```


A good rule of thumb is that an anonymous function should fit on one line and shouldn’t need to use {}.

```{r}
sapply(mtcars, function(x) length(unique(x)))
```


```{r}
match.fun(mean)
```

Lexical scoping

-four primary rules it follows

```{r}
# Name Masking
#   -names defined inside a function mask names defined outside a function

x <- 10
y <- 20
g02 <- function() {
  x <- 1
  y <- 2
  c(x, y)
}
g02() # outputs 1 2 not 10 20

# If a name isn’t defined inside a function, R looks one level up.

x <- 2
g03 <- function() {
  y <- 1
  c(x, y)
}
g03() # outputs 2 1 and importantly

y # ouputs 20 which was the old value for y
```

```{r}
# Functions vs variables

# the same scoping rules apply to functions as well as objects

g09 <- function(x) x + 100
g10 <- function() {
  g09 <- 10
  g09(g09)
}
g10() # this outputs 110 because we have both an object and a function defined as g09

```

```{r}
# A fresh start

#every time a function is called a new environment is created to host its execution. This means that a function #has no way to tell what happened the last time it was run; each invocation is completely independent.
```

```{r}
# dynamic lookup

# R looks for values when the function is run, not when the function is created

g12 <- function() x + 1
x <- 15
g12() # outputs 16


x <- 20
g12() # outputs 21, because we assigned 20 to x before running the function again



```


```{r}
c <- 10
c(c = c)
```

What does this do?

```{r}
f <- function(x) {
  f <- function(x) {
    f <- function() {
      x ^ 2
    }
    f() + 1
  }
  f(x) * 2
}
f(10) # 202
```

Lazy evaluation

```{r}
# promises

# three components

# an expression which gives rise to delayed computation
# an environment where the expression should be evaluated
#   This also means that when you do assignment inside a call to a function, the variable is bound outside of the
#   function, not inside of it.
# A value, which is computed and cached the first time a promise is accessed when the expression is evaluated in
# the specified environment.
```

```{r}
# default arguments

h04 <- function(x = 1, y = x * 2, z = a + b) {
  a <- 10
  b <- 100
  
  c(x, y, z)
}

h04() # outputs 1 2 110 this shows off default values that we set ourselves


# missing arguments


```

```{r}
args(sample) # a cool way to check arguments of a function, notice no ()
```

```{r}
sample1 <- function(x, size = NULL, replace = FALSE, prob = NULL) {
  if (is.null(size)) {
    size <- length(x)
  }
  
  x[sample.int(length(x), size, replace = replace, prob = prob)]
}

sample1(1:20)
sample(1:20)
```

&& does not perform elementwise comparisons, instead it uses the first element of each value only

```{r}
attr(sample, "srcref")
args(sample)
```


```{r}
f2 <- function(x = z) {
  z <- 100
  x
}
f2()
```

```{r}
y <- 10
f1 <- function(x = {y <- 1; 2}, y = 0) {
  c(x, y)
}
f1()

```

```{r}
# dot-dot-dot ...

i04 <- function(...) {
  list(...)
}

i04(a = 1, b = 2, j = "jack") # just an example

# the primary uses of ...

#If your function takes a function as an argument, you want some way to pass additional arguments to that #function.

# some downsides, a misspelled argument will not cause an error

sum(1,2,3,NA, na_rm = T) # returns NA since we typed na_rm not na.rm

```


```{r}
args(mean)

sum(1, 2, 3, na.omit = TRUE) # returns 7 because we wrote na.omit instead of na.rm and so the T is read as 1

# lets look at the arguments

str(sum) # we can see that the first arguments are ... and the other is the status of na.rm, so we can do
sum(1,2,3,4)

str(mean) # here we can see that x is the first argument and the rest is ... so we cant do 
mean(1,2,3)
# instead we do
mean(c(1,2,3))

str(plot)
```

```{r}
# exiting a function

# Most functions exit in one of two ways: they either return a value, indicating success, or they throw an
# error, indicating failure

# implicit vs explicit

## implicitly, where the last evaluated expression is the return value:
## Explicitly, by calling return()

# invisible values

j03 <- function() 1
j03() # usually it works like this where just calling the function prints an output

# but we can also do this to prevent the output from being printed
j04 <- function() invisible(1)
j04() # this outputs nothing

# the most common usage of invisible functions is the <-, for ex a <- 1 doesnt output anything

# to see the output we can wrap in parenthesis

(j04()) # this outputs 1 which is normally invisible
```

### Environments

```{r}
library(rlang)

# how to create an environment
e1 <- env(
  a = FALSE,
  b = "a",
  c = 2.3,
  d = 1:3,
)

# use new.env to create a new environment

env_print(e1) # this helps you look at environment
env_names(e1)
```


```{r}
# important environments

current_env()

global_env()

identical(current_env(), global_env()) # outputs TRUE
```

```{r}
# parents

# every environment has a parent, another environment
# if a name is not found in an environment R will look to the parent and so on

e2a <- env(d = 4, e = 5)
e2b <- env(e2a, a = 1, b = 2, c = 3)

env_print(e2a)
```





